package com.peiowang.tools.aicr.excuters;

public class V55CodeLlamaExcuter extends BaseTestModelExcuter {

    private static final String MODEL = "xiaohanlu/results/CodeLLama34B/merged_lora/CodeLLM-f5-5-RAG-STEP2-v2-3epoch";
    private static final String TEMPLATE = "llama2";
    private static final String LLM_ENDPOINT = "http://lowpeak03.git.woa.com/v1/completions";


    public static void main(String[] args) {
        String prompt = "你是一个Java语言代码审查员，你的任务是根据评测要点审查代码，判断第153-157行代码是否存在评审要点提到的问题。\\n```\\n110         public void convertGrayPlanFilterConf(List<TPlanVersion> planVersions) {\\n111             if (CollectionUtils.isEmpty(planVersions)) {\\n112                 return;\\n113             }\\n114             Map<String, List<PlanFilterEntity>> planFilterEntityMap = new HashMap<>();\\n115             // List<PlanFilterEntity> planFilterEntityList = Lists.newArrayList();\\n116             for (TPlanVersion planVersion : planVersions) {\\n117                 if (planVersion.getFappid() != appIdUtil.getLctAppId()) {\\n118                     return;\\n119                 }\\n120                 if (StringUtils.isBlank(planVersion.getFfilterConf())) {\\n121                     continue;\\n122                 }\\n123                 // 仅单资产 or 产品组需要调用业务打平规则表达式\\n124                 PlanFilterConf planFilterConf = PlanFilterUtil.parseFilterProdConf(planVersion.getFfilterConf());\\n125                 Integer productType = planFilterConf.getProductType();\\n126                 if (!FilterProdTypeEnum.SINGLE_ASSET_PROD_TYPE.getType().equals(productType)\\n127                         && !FilterProdTypeEnum.ASSET_GROUP_PROD_TYPE.getType().equals(productType)) {\\n128                     continue;\\n129                 }\\n130     \\n131                 String adOwner = StringUtils.isBlank(planVersion.getAdOwner())\\n132                         ? StringUtils.EMPTY : planVersion.getAdOwner();\\n133                 List<PlanFilterEntity> planFilterEntityList = planFilterEntityMap.getOrDefault(adOwner, new ArrayList<>());\\n134                 PlanFilterEntity planFilterEntity = new PlanFilterEntity();\\n135                 planFilterEntity.setDpId(planVersion.getFdpId());\\n136                 planFilterEntity.setFilterConf(planVersion.getFfilterConf());\\n137                 planFilterEntityList.add(planFilterEntity);\\n138                 planFilterEntityMap.put(adOwner, planFilterEntityList);\\n139             }\\n140             // 分批并发获取\\n141             List<PlanFilterEntity> resultList = Lists.newArrayList();\\n142             for (String key : planFilterEntityMap.keySet()) {\\n143                 List<PlanFilterEntity> planFilterEntityList = planFilterEntityMap.get(key);\\n144                 List<List<PlanFilterEntity>> planFilterEntityBatchList = Lists.partition(planFilterEntityList, pageSize);\\n145                 List<CompletableFuture<Void>> futures = Lists.newArrayList();\\n146                 for (List<PlanFilterEntity> planFilterEntities : planFilterEntityBatchList) {\\n147                     futures.add(furecomItemSlowAoRpcService.queryFilterProdData(planFilterEntities, key,\\n148                             String.valueOf(appIdUtil.getLctAppId())));\\n149                     resultList.addAll(planFilterEntities);\\n150                 }\\n151                 CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();\\n152             }\\n153             for (TPlanVersion planVersion : planVersions) {\\n154                 Optional<PlanFilterEntity> planFilterEntity = resultList.stream()\\n155                         .filter(p -> p.getDpId().equals(planVersion.getFdpId())).findFirst();\\n156                 planFilterEntity.ifPresent(filterEntity -> planVersion.setFfilterConf(filterEntity.getFilterData()));\\n157             }\\n158         }\\n\\n```\\n\\n你需要关注下面这些评审要点：\\n## 函数嵌套层次过深（超过4层），应该使用卫语句和提前return优化\\n\\n反面案例：\\n```\\npublic String getQueryWhereSql(PanelCard card, List<DimParam> dimParams)\\n        throws BizServiceException {// 第一层\\n    StringBuffer whereSql = new StringBuffer();\\n    try {// 第二层\\n         if (null != dimParams && dimParams.size() > 0) { // 第三层\\n             for (CrowdCard.DimParam dimParam : dimParams) { // 第四层\\n                String key = dimParam.getFieldKey();\\n                // 普通维度\\n                if (key.startsWith(\\\"dim_\\\")) {// 第五层\\n                    // ...\\n                    if (!dimFieldKey.matches(SqlAstUtils.NUMBER_REG)) { // 第六层\\n                        if (DataResourceEventAnalysisService.DimType.MEANING.value().equalsIgnoreCase(dim.getDimType())) { // 第七层\\n                            // ... \\n                        } else{\\n                            // ...\\n                        }\\n                    }\\n                } else {\\n                    throw new BizServiceException(\\\"非法的维度名称：\\\" + key);\\n                }\\n            }\\n        } \\n        // ... \\n    } catch (Exception thr) {\\n        throw new BizServiceException(\\\"维度过滤异常:\\\"+card.getId(), thr);\\n    }\\n    return whereSql.toString();\\n}\\n```\\n\\n正面案例：\\n```\\npublic String getQueryWhereSql(PanelCard card, List<DimParam> dimParams)\\n            throws BizServiceException { // 第一层\\n        // [tips]: 关注异常处理和特殊逻辑\\n        try { // 第二层\\n            if(null == dimParams || dimParams.isEmpty()){\\n                return \\\"\\\";  // [tips]: 通过卫语句提前返回，减少其他代码的嵌套\\n            }\\n            StringBuffer whereSql = new StringBuffer();\\n            ... 省略其他代码\\n            for (CrowdCard.DimParam dimParam : dimParams) { // 第三层\\n                String key = dimParam.getFieldKey();\\n                // 普通维度\\n                if(!key.startsWith(\\\"dim_\\\")){ // 第四层\\n                    throw new BizServiceException(\\\"非法的维度名称：\\\" + key);\\n                }\\n                whereSql.append(parseDimParam(dim));\\n            }  \\n            return whereSql.toString();\\n        } catch (Exception thr) {\\n            throw new BizServiceException(\\\"维度过滤异常:\\\"+card.getId(), thr);\\n        }\\n    }\\n\\n\\nprivate String parseDimParam (DimParam dim){  // 第一层\\n    if (!dimFieldKey.matches(SqlAstUtils.NUMBER_REG)) { // 第二层\\n       if (DataResourceEventAnalysisService.DimType.MEANING.value().equalsIgnoreCase(dim.getDimType())) { // 第三层\\n            // ... \\n       } else{\\n           // ...\\n       }\\n    }\\n}\\n```\\n\\n\\n## Stream流处理lambda表达式中代码块过多（超过3行）\\n\\n反面案例：\\n```\\nvoid process() {\\n    List<FilterComponent> filterComponents = list.stream()\\n        .filter(e -> {\\n            // 超过三行的代码块\\n            Map<String, Scope> scopeMap = e.getScope().stream()\\n                    .collect(Collectors.toMap(Scope::getComponentId, Function.identity(), (k1, k2) -> k1));\\n            Scope scope = scopeMap.get(componentId);\\n            if (null == scope || !scope.isComponentSwitch()) {\\n                return false;\\n            }\\n            if (!FilterModelType.DATE.getValue().equals(e.getModelType())) {\\n                return false;\\n            }\\n            return true;\\n        }).collect(Collectors.toList());\\n}\\n```\\n\\n正面案例：\\n```\\nvoid process() {\\n    List<FilterComponent> filterComponents = list.stream()\\n        .filter(e -> isMatchScope(e, componentId))\\n        .collect(Collectors.toList());\\n}\\n\\n// 剥离出isMatchScope函数, 主逻辑代码更清晰，同时也更容易对isMatchScopre建立单独的测试case\\nprivate boolean isMatchScope(FilterComponent component, String targetComponentId) {\\n    Map<String, Scope> scopeMap = component.getScope().stream()\\n            .collect(Collectors.toMap(Scope::getComponentId, Function.identity(), (k1, k2) -> k1));\\n    Scope scope = scopeMap.get(targetComponentId);\\n    if (null == scope || !scope.isComponentSwitch()) {\\n        return false;\\n    }\\n    if (!FilterModelType.DATE.getValue().equals(component.getModelType())) {\\n        return false;\\n    }\\n    return true;\\n}\\n```\\n\\n\\n\\n\\n\\n请将审查结果按下面的JSON格式要求输出：\\n```\\n  {\\n    \\\"是否存在问题\\\": \\\"是｜否｜无法判断\\\",\\n    \\\"违反的评审要点\\\": xxx,\\n    \\\"审查结果\\\": xxx,\\n    \\\"起始行\\\": xxx,\\n    \\\"终止行\\\": xxx\\n  }\\n```\\n\\nJSON字段要求：\\n是否存在问题：判断第153-157行代码是否存在上述评审要点提到的问题，如果代码上下文的信息不足无法给出判断，请填写\\\"无法判断\\\"。\\n违反的评审要点：如果第153-157行代码确实存在问题，请指出该问题对应的评审要点。\\n审查结果：请给出专业的评审结果。\\n起始行、终止行：问题代码的具体行号范围。";
        doInfer(prompt, MODEL, TEMPLATE, LLM_ENDPOINT);
    }

    public static String excute(String prompt) {
        return doInfer(prompt, MODEL, TEMPLATE, LLM_ENDPOINT);
    }
}
